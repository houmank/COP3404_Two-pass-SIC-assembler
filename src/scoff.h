// Author(s): Houman Karimi
// Date: 10/05/2021
// Course: COP3404

#ifndef SCOFF_H // SIC Common Object File Format
#define SCOFF_H

// local includes //

#include "directive.h"
#include "linked_list.h"
#include "sic.h"

// Standard library includes //

#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <stdint.h>

// Defines // 

#define SCOFF_HEADER_FIELD_LEN 6

#define SCOFF_TEXT_ADDR_LEN 6 
#define SCOFF_TEXT_SIZE_LEN 2
#define SCOFF_TEXT_OBJ_CODE_LEN 60

#define SCOFF_MOD_ADDR_LEN 6
#define SCOFF_MOD_HB 4
#define SCOFF_MOD_SIZE_LEN 2
#define SCOFF_MOD_SYMBOL_LEN SIC_MAX_SYMBOL_LEN

#define SCOFF_END_FIRST_INSTRUCTION_LEN 6

#define SCOFF_INDEXED_SUBSTR ",X"
#define SCOFF_INDEXED_BIT (1 << 15)

#define SCOFF_OBJ_EXTENSION_LEN 4
#define SCOFF_OBJ_EXTENSION ".obj"
#define SCOFF_INSTRUCTION_PAD 4

// Structs and enums //

/**
 * @brief sic_scoff_header is a struct that holds the data
 * for a scoff header record. There should be only one header record for each sic program.
 * The first character of each header is the
 * magic character 'H'. After that columns 2-7 hold the program name (symbol attached to start).
 * The columns 8-13 hold the starting address of the program in hex. 
 * Then lastly, the columns 14-19 hold the length of the program in hex.
 * These are stored in the magicChar, programName[], startAddr[], and
 * lengthOfObj respectively.
 */
typedef struct
{
	char magicChar;
	char programName[SCOFF_HEADER_FIELD_LEN + 1];
	char startAddr[SCOFF_HEADER_FIELD_LEN + 1];
	char lengthOfProgram[SCOFF_HEADER_FIELD_LEN + 1];
} sic_scoff_header;

/**
 * @brief sic_scoff_text is a struct that holds the data for a scoff text record.
 * The first character for each text record is the character 'T'. Next the columns 2-7
 * will hold the start address for the object in hex. The columns 8-9 hold the obj code size in hex.
 * It will also hold the columns 10-69 hold the object code in hex.
 * This record holds the bytes which comprise the executable instructions and constants for the sic program.
 */
typedef struct
{
	char magicChar;
	char startAddr[SCOFF_TEXT_ADDR_LEN + 1];
	char lengthOfObj[SCOFF_TEXT_SIZE_LEN + 1];
	char objectCode[SCOFF_TEXT_OBJ_CODE_LEN + 1];
} sic_scoff_text;

typedef struct
{
	char magicChar;
	char startAddr[SCOFF_MOD_ADDR_LEN + 1];
	char lenOfModificationHB[SCOFF_MOD_SIZE_LEN + 1];
	char modificationFlag;
	char symbolName[SCOFF_MOD_SYMBOL_LEN + 1];
} sic_scoff_mod;

/**
 * @brief sic_scoff_end is a struct that holds the data for a scoff end record.
 * The first character for each end record is the character 'E'. There should only be one
 * end record per program. The columns 2-7 hold the address of first executable instruction in hex.
 * This record instructs the loader where to set the program counter, and denotes end of object file.
 */
typedef struct
{
	char magicChar;
	char firstInstruction[SCOFF_END_FIRST_INSTRUCTION_LEN + 1];
} sic_scoff_end;

/**
 * @brief sic_scoff_records is the generated records of a given sic assembly file. This struct is a wrapper
 * around the different record types generated by pass two of the sic assembler. The struct contains
 * one header, a linked list of texts, a linked list of modification records, and an end record. 
 */
typedef struct
{
	sic_scoff_header header;
	linked_list* texts;
	linked_list* modifications;
	sic_scoff_end end;

} sic_scoff_records;

// Functions //

/**
 * @brief freeRecords is a function that will deallocate a givne sic_scoff_records struct.
 * The function will accept a pointer to the struct which will be freed, and the function
 * returns nothing.
 *
 * @param  records - The records to be freed
 * @return void
*/
void freeRecords(sic_scoff_records* records);

/**
 * @brief generateSCOFFRecords is a function that will do part of pass 2 of the assembler. It will be reponsible for parsing the
 * SIC assembly file again in order to generate the records. The function will accept
 * an openSIC file that has file stream pointer set to beginning of file, a directive table, a opcode table, and a symbol table from pass one.
 * The function will return the sic_scoff_records* and on error, the function will return NULL and set the numRecords to zero.
 *
 * The function will not check to see if the given pointers are valid. Caller must ensure they are valid to avoid a segfault.
 * 
 * @param  openSIC		      - The open SIC assembly file.
 * @param  directiveTable     - Directive table used to call directive functions.
 * @param  opcodeTable        - The optab where all of the instructions and their opcodes, mnumonics, formats, size, and flags are stored.
 * @param  symbolTable        - The symbol table where the pass one symbols are stored with their corresponding addresses. It also has start and possibly end address.
 * @return sic_scoff_records* - Struct holding all of the records associated with the SCOFF
 */
sic_scoff_records* generateSCOFFRecords( FILE* openSIC, hash_table* directiveTable, hash_table* opTab, symbol_table* symTab);


/**
 * @brief writeSCOFFToFile is a function that takes a records struct and outputs the records into an .obj file for SIC.
 * The function will accept the pointer to a records struct and the fileName which will be given to the newly created .obj file.
 * The function will return the given records pointer, or NULL if an error occurred.
 * 
 * @param  records   - The records struct that will be writen to the obj file.
 * @param  fileName  - The name that will be given to the obj file.
 * @return The given records pointer, or NULL on error.
*/
sic_scoff_records* writeSCOFFToFile(sic_scoff_records* records, char* fileName);

#endif //SCOFF_H